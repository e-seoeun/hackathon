Index: downloader/spacetrack_auth.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>identity=dldi0802@yonsei.ac.kr\r\npassword=\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/downloader/spacetrack_auth.txt b/downloader/spacetrack_auth.txt
--- a/downloader/spacetrack_auth.txt	(revision ffff2866581a3384db8dc4bb5b7932a2ce5c8034)
+++ b/downloader/spacetrack_auth.txt	(date 1769473037092)
@@ -1,2 +1,2 @@
 identity=dldi0802@yonsei.ac.kr
-password=
+password=**dlwldud120102
Index: process3_plot.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># -*- coding: utf-8 -*-\r\nimport csv\r\nimport math\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\nfrom astropy.wcs import WCS\r\n\r\nIN_TRACK_CSV = \"20250517_result.csv\"              # t_offset 포함된 원본\r\nIN_DVDM_CSV  = \"20250517_result_dv_dm_d1d2.csv\"   # dv/dm/d1/d2 요약\r\nD2R = math.pi / 180.0\r\n\r\ndef to_float(x):\r\n    if x is None:\r\n        return float(\"nan\")\r\n    s = str(x).strip()\r\n    if s == \"\" or s.lower() in (\"nan\", \"none\", \"unset\"):\r\n        return float(\"nan\")\r\n    try:\r\n        return float(s)\r\n    except Exception:\r\n        return float(\"nan\")\r\n\r\ndef is_finite(x):\r\n    return (x is not None) and math.isfinite(x)\r\n\r\ndef wrap180_deg(d):\r\n    return (d + 180.0) % 360.0 - 180.0\r\n\r\ndef unwrap_about_center(ra_deg_arr, ra_center):\r\n    ra_deg_arr = np.asarray(ra_deg_arr, float)\r\n    return ra_center + (wrap180_deg(ra_deg_arr - ra_center))\r\n\r\ndef choose_center(ra_arr, dec_arr):\r\n    ra0 = float(ra_arr[0])\r\n    ra_rel = wrap180_deg(np.asarray(ra_arr) - ra0)\r\n    ra_center = (ra0 + float(np.median(ra_rel))) % 360.0\r\n    dec_center = float(np.median(dec_arr))\r\n    return ra_center, dec_center\r\n\r\ndef load_tracks_for_norad(path, norad_id, window_s=5):\r\n    \"\"\"\r\n    returns dict:\r\n      {\r\n        \"epoch_time_utc\": str,\r\n        \"site_lat_deg\": float,\r\n        \"site_lon_deg\": float,\r\n        \"site_alt_m\": float,\r\n        \"t_offset\": [..],\r\n        \"today_ra\": [..], \"today_dec\":[..],\r\n        \"prev_ra\":  [..], \"prev_dec\":[..],\r\n      }\r\n    첫 매칭된 epoch 그룹을 사용. (여러 그룹이면 가장 먼저 읽힌 것)\r\n    \"\"\"\r\n    target = str(norad_id).strip()\r\n\r\n    rows = []\r\n    with open(path, \"r\", encoding=\"utf-8-sig\", newline=\"\") as f:\r\n        r = csv.DictReader(f)\r\n        for row in r:\r\n            if (row.get(\"norad_id\") or \"\").strip() != target:\r\n                continue\r\n            try:\r\n                dt = int(float(row.get(\"t_offset_s\")))\r\n            except Exception:\r\n                continue\r\n            if dt < -window_s or dt > window_s:\r\n                continue\r\n            rows.append(row)\r\n\r\n    if not rows:\r\n        return None\r\n\r\n    # epoch/site 키로 그룹핑: 보통 한 norad_id에 한 그룹이지만, 안전하게 처리\r\n    # 여기서는 \"첫 그룹\"만 사용\r\n    def key_of(row):\r\n        return (\r\n            (row.get(\"epoch_time_utc\") or \"\").strip(),\r\n            (row.get(\"site_lat_deg\") or \"\").strip(),\r\n            (row.get(\"site_lon_deg\") or \"\").strip(),\r\n            (row.get(\"site_alt_m\") or \"\").strip(),\r\n            (row.get(\"sat_name\") or \"\").strip(),\r\n            (row.get(\"epoch_diff_sec\") or \"\").strip(),\r\n        )\r\n\r\n    first_key = key_of(rows[0])\r\n    rows = [rw for rw in rows if key_of(rw) == first_key]\r\n\r\n    # t_offset 기준 정렬\r\n    rows.sort(key=lambda rw: int(float(rw.get(\"t_offset_s\"))))\r\n\r\n    out = {\r\n        \"epoch_time_utc\": first_key[0],\r\n        \"site_lat_deg\": to_float(first_key[1]),\r\n        \"site_lon_deg\": to_float(first_key[2]),\r\n        \"site_alt_m\": to_float(first_key[3]),\r\n        \"sat_name\": first_key[4],\r\n        \"epoch_diff_sec\": round(to_float(first_key[5])/3600, 2),\r\n        \"t_offset\": [],\r\n        \"today_ra\": [], \"today_dec\": [],\r\n        \"prev_ra\":  [], \"prev_dec\":  [],\r\n    }\r\n\r\n    for rw in rows:\r\n        out[\"t_offset\"].append(int(float(rw.get(\"t_offset_s\"))))\r\n        out[\"today_ra\"].append(to_float(rw.get(\"today_ra_deg\")))\r\n        out[\"today_dec\"].append(to_float(rw.get(\"today_dec_deg\")))\r\n        out[\"prev_ra\"].append(to_float(rw.get(\"prev_ra_deg\")))\r\n        out[\"prev_dec\"].append(to_float(rw.get(\"prev_dec_deg\")))\r\n\r\n\r\n    # NaN 제거(동시에)\r\n    def _mask(ra, dec):\r\n        ra = np.asarray(ra, float); dec = np.asarray(dec, float)\r\n        m = np.isfinite(ra) & np.isfinite(dec)\r\n        return ra[m], dec[m]\r\n\r\n    out[\"today_ra\"], out[\"today_dec\"] = _mask(out[\"today_ra\"], out[\"today_dec\"])\r\n    out[\"prev_ra\"],  out[\"prev_dec\"]  = _mask(out[\"prev_ra\"],  out[\"prev_dec\"])\r\n\r\n    return out\r\n\r\ndef load_dvdm_for_norad(path, norad_id):\r\n    \"\"\"\r\n    returns dict with dv/dm/d1/d2 etc. if exists.\r\n    같은 norad_id가 여러 줄이면 첫 줄 사용.\r\n    \"\"\"\r\n    target = str(norad_id).strip()\r\n    with open(path, \"r\", encoding=\"utf-8-sig\", newline=\"\") as f:\r\n        r = csv.DictReader(f)\r\n        for row in r:\r\n            if (row.get(\"norad_id\") or \"\").strip() != target:\r\n                continue\r\n            return {\r\n                \"today_dv\": to_float(row.get(\"today_dv\")),\r\n                \"prev_dv\":  to_float(row.get(\"prev_dv\")),\r\n                \"today_dm\": to_float(row.get(\"today_dm\")),\r\n                \"prev_dm\":  to_float(row.get(\"prev_dm\")),\r\n                \"dm_diff\":  to_float(row.get(\"dm_diff\")),\r\n                \"d1\":       to_float(row.get(\"d1\")),\r\n                \"d2\":       to_float(row.get(\"d2\")),\r\n                \"epoch_time_utc\": (row.get(\"epoch_time_utc\") or \"\").strip(),\r\n                \"epoch_diff_sec\": to_float(row.get(\"epoch_diff_sec\")),\r\n            }\r\n    return None\r\n\r\n\r\n\r\nfrom matplotlib.markers import MarkerStyle\r\n\r\ndef mark_oriented_triangle_world(ax, ra_deg_arr, dec_deg_arr, transform,\r\n                                 size=10, color=\"k\", ahead_px=1, mode=\"local\", z=10):\r\n    \"\"\"\r\n    ra/dec 배열의 진행방향을 보고, 마지막 점에 삼각형(화살표처럼) 표시.\r\n    - transform: ax.get_transform(\"world\") 넣어야 함\r\n    - mode=\"local\": 마지막 구간 방향(권장)\r\n    \"\"\"\r\n    if ra_deg_arr is None or dec_deg_arr is None:\r\n        return\r\n    ra_deg_arr = np.asarray(ra_deg_arr, float)\r\n    dec_deg_arr = np.asarray(dec_deg_arr, float)\r\n\r\n    m = np.isfinite(ra_deg_arr) & np.isfinite(dec_deg_arr)\r\n    if not np.any(m):\r\n        return\r\n    ra_deg_arr = ra_deg_arr[m]\r\n    dec_deg_arr = dec_deg_arr[m]\r\n    if len(ra_deg_arr) < 2:\r\n        return\r\n\r\n    # 마지막 유효한 두 점 선택\r\n    j = len(ra_deg_arr) - 1\r\n    i = j - 1\r\n    while i >= 0:\r\n        if (ra_deg_arr[i] != ra_deg_arr[j]) or (dec_deg_arr[i] != dec_deg_arr[j]):\r\n            break\r\n        i -= 1\r\n    if i < 0:\r\n        return\r\n\r\n    # world -> display 로 변환해서 각도 계산\r\n    P = transform.transform(np.array([[ra_deg_arr[i], dec_deg_arr[i]],\r\n                                      [ra_deg_arr[j], dec_deg_arr[j]]], float))\r\n    p0, p1 = P[0], P[1]\r\n    v = p1 - p0\r\n    nrm = float(np.hypot(v[0], v[1]))\r\n    if nrm <= 0:\r\n        return\r\n    u = v / nrm\r\n    angle_deg = float(np.degrees(np.arctan2(u[1], u[0])))\r\n\r\n    # 약간 앞으로 뺀 지점에 마커 찍기\r\n    p_end = p1 + u * float(ahead_px)\r\n    ra_end, dec_end = transform.inverted().transform(p_end)\r\n\r\n    mk = MarkerStyle((3, 0, angle_deg + 30))  # 삼각형 방향 맞추기\r\n    ax.plot([ra_end], [dec_end],\r\n            marker=mk, markersize=float(size),\r\n            markerfacecolor=color, markeredgewidth=0.0, markeredgecolor=\"none\",\r\n            linestyle=\"None\", transform=transform, zorder=z, alpha=0.8,\r\n            clip_on=True)\r\n\r\n\r\n\r\ndef create_wcs_axes(ra0_deg, dec0_deg, fov_ra_deg=10.0, fov_dec_deg=10.0, npix=1200, projection=\"TAN\"):\r\n    wcs = WCS(naxis=2)\r\n    wcs.wcs.crpix = [npix/2 + 0.5, npix/2 + 0.5]\r\n    wcs.wcs.crval = [ra0_deg, dec0_deg]\r\n    wcs.wcs.ctype = [f\"RA---{projection}\", f\"DEC--{projection}\"]\r\n    wcs.wcs.cdelt = np.array([fov_ra_deg/npix, fov_dec_deg/npix], dtype=float)\r\n\r\n    fig = plt.figure(figsize=(10, 8))\r\n    ax = fig.add_subplot(111, projection=wcs)\r\n    ax.set_xlim(0.5, npix + 0.5)\r\n    ax.set_ylim(0.5, npix + 0.5)\r\n\r\n    ax.coords.grid(True, color=\"0.5\", linestyle=\"dotted\", alpha=0.8)\r\n\r\n    # 축 라벨 크기\r\n    ax.coords[0].set_axislabel(\"RA (J2000)\", fontsize=14)\r\n    ax.coords[1].set_axislabel(\"Dec (J2000)\", fontsize=14)\r\n\r\n    # 포맷만 지정 (fontsize 넣지 말기)\r\n    ax.coords[0].set_major_formatter(\"hh:mm\")\r\n    ax.coords[1].set_major_formatter(\"dd\")\r\n\r\n    # 눈금 글씨 크기\r\n    ax.coords[0].set_ticklabel(size=14)\r\n    ax.coords[1].set_ticklabel(size=14)\r\n\r\n    return fig, ax, wcs\r\n\r\ndef main():\r\n    norad_id = input(\"NORAD ID 입력: \").strip()\r\n\r\n    tr = load_tracks_for_norad(IN_TRACK_CSV, norad_id, window_s=5)\r\n    if tr is None:\r\n        print(f\"[ERROR] {IN_TRACK_CSV}에서 norad_id={norad_id} 데이터를 못 찾음\")\r\n        return\r\n\r\n    dv = load_dvdm_for_norad(IN_DVDM_CSV, norad_id)\r\n    if dv is None:\r\n        print(f\"[WARN] {IN_DVDM_CSV}에서 norad_id={norad_id} dv/dm/d1/d2를 못 찾음\")\r\n\r\n    # center: today 기준(없으면 prev 기준)\r\n    if len(tr[\"today_ra\"]) >= 1:\r\n        ra_center, dec_center = choose_center(tr[\"today_ra\"], tr[\"today_dec\"])\r\n    else:\r\n        ra_center, dec_center = choose_center(tr[\"prev_ra\"], tr[\"prev_dec\"])\r\n\r\n    # unwrap(경계 넘어가는 경우 대비)\r\n    today_ra_u = unwrap_about_center(tr[\"today_ra\"], ra_center) if len(tr[\"today_ra\"]) else np.array([])\r\n    prev_ra_u  = unwrap_about_center(tr[\"prev_ra\"],  ra_center) if len(tr[\"prev_ra\"])  else np.array([])\r\n\r\n    # FOV: ra±5, dec±5\r\n    fov_ra_deg  = 30.0\r\n    fov_dec_deg = 30.0\r\n\r\n    fig, ax, wcs = create_wcs_axes(ra_center, dec_center, fov_ra_deg=fov_ra_deg, fov_dec_deg=fov_dec_deg,\r\n                                   npix=1200, projection=\"TAN\")\r\n    world = ax.get_transform(\"world\")\r\n\r\n    # plot: today / prev\r\n    if len(today_ra_u):\r\n        ax.plot(today_ra_u, tr[\"today_dec\"], \"-\", linewidth=2.5, alpha=0.8,\r\n                transform=world, zorder=5, label=\"today\", color=\"red\")\r\n        '''ax.plot(today_ra_u, tr[\"today_dec\"], \"o\", markersize=4, alpha=0.8,\r\n                transform=world, zorder=6)'''\r\n        mark_oriented_triangle_world(ax, today_ra_u, tr[\"today_dec\"], world,\r\n                                     size=12, color=\"red\", ahead_px=2, z=20)\r\n\r\n\r\n    if len(prev_ra_u):\r\n        ax.plot(prev_ra_u, tr[\"prev_dec\"], \"-\", linewidth=2.5, alpha=0.8,\r\n                transform=world, zorder=4, label=\"prev\", color=\"royalblue\")\r\n        '''ax.plot(prev_ra_u, tr[\"prev_dec\"], \"o\", markersize=4, alpha=0.8,\r\n                transform=world, zorder=4)'''\r\n        mark_oriented_triangle_world(ax, prev_ra_u, tr[\"prev_dec\"], world,\r\n                                     size=12, color=\"royalblue\", ahead_px=2, z=19)\r\n\r\n    # title\r\n    epoch = tr['epoch_time_utc'].replace(\"T\", \" \").replace(\"Z\", \"\")\r\n    object_name = tr['sat_name']\r\n    diff_time = tr['epoch_diff_sec']\r\n    ax.set_title(f\"TLE date 2025-05-17 \\n NORAD ID {norad_id} | Epoch {epoch}\", fontsize=18)\r\n\r\n    # bottom text (dv/dm/d1/d2)\r\n    lines = []\r\n    if object_name:\r\n        ax.text(\r\n            0.02, 0.19,  # ← 살짝 위로\r\n            object_name,\r\n            transform=ax.transAxes,\r\n            ha=\"left\", va=\"bottom\",\r\n            fontsize=18,  # ← 크게\r\n            fontweight=\"bold\",\r\n            color=\"black\",\r\n            bbox=dict(boxstyle=\"round,pad=0.25\", fc=\"white\", ec=\"none\", alpha=0.85),\r\n            zorder=101\r\n        )\r\n    if dv is not None:\r\n        if is_finite(dv.get(\"today_dv\")) and is_finite(dv.get(\"prev_dv\")):\r\n            dvper = (dv[\"today_dv\"] - dv[\"prev_dv\"]) / dv[\"today_dv\"] * 100\r\n            lines.append(f\"AV   {dv['today_dv']:.4f} / {dv['prev_dv']:.4f} (DV {dv['today_dv']-dv['prev_dv']:.4f}°/s, {dvper:+.1f}%)\")\r\n        elif is_finite(dv.get(\"today_dv\")):\r\n            lines.append(f\"AV   {dv['today_dv']:.4f}  (deg/s)\")\r\n\r\n\r\n        if is_finite(dv.get(\"today_dm\")) and is_finite(dv.get(\"prev_dm\")):\r\n            if is_finite(dv.get(\"dm_diff\")):\r\n                lines.append(f\"MA   {dv['today_dm']:.1f} / {dv['prev_dm']:.1f}  (DA {dv['dm_diff']:+.1f}°)\")\r\n            else:\r\n                lines.append(f\"MA   {dv['today_dm']:.1f} / {dv['prev_dm']:.1f}\")\r\n        elif is_finite(dv.get(\"today_dm\")):\r\n            lines.append(f\"Da   {dv['today_dm']:.1f}\")\r\n\r\n        if is_finite(dv.get(\"d1\")):\r\n            lines.append(f\"D1   {dv['d1']:.2f}°\")\r\n        if is_finite(dv.get(\"d2\")):\r\n            lines.append(f\"D2   {dv['d2']:+.2f}°\")\r\n\r\n        if diff_time:\r\n            lines.append(f\"DT   {diff_time} h\")\r\n\r\n    if lines:\r\n        ax.text(\r\n            0.02, 0.02, \"\\n\".join(lines),\r\n            transform=ax.transAxes, ha=\"left\", va=\"bottom\",\r\n            fontsize=14, color=\"black\",\r\n            bbox=dict(boxstyle=\"round,pad=0.25\", fc=\"white\", ec=\"none\", alpha=0.85),\r\n            zorder=100\r\n        )\r\n\r\n    # legend\r\n    ax.legend(loc=\"upper right\", framealpha=0.0, edgecolor=\"none\", fontsize=14)\r\n\r\n\r\n    plt.tight_layout()\r\n    plt.show()\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/process3_plot.py b/process3_plot.py
--- a/process3_plot.py	(revision ffff2866581a3384db8dc4bb5b7932a2ce5c8034)
+++ b/process3_plot.py	(date 1769475314109)
@@ -339,4 +339,4 @@
     plt.show()
 
 if __name__ == "__main__":
-    main()
+    main()
\ No newline at end of file
Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># main.py\r\n'''\r\nhackathon\r\nㄴdownloder\r\n    ㄴspacetrack_messages\r\n        ㄴdecay\r\n            decay_YYYYMMDD.csv\r\n            .\r\n            .\r\n            .\r\n    spacetrack_auth.txt (ID 및 Password 입력)\r\n        ㄴtip\r\n            tip_YYYYMMDD.csv\r\n            .\r\n            .\r\n            .\r\n    process0_downladder.py\r\n    spacetrack_auth.txt\r\n\r\nㄴrepository\r\n    ㄴtle_data\r\n        YYYYMMDD.tle (날짜별 tle데이터가 미리 다운받아 있어야 합니다.)\r\n        .\r\n        .\r\n        .\r\n\r\nmain.py\r\nprocess1_track.py\r\nprocess2_calculate.py\r\nprocess3_plot.py\r\n\r\n\r\n* process0 \r\nspacetrack에서 원하는 기간동안의 decay message와 tip message를 다운받아 날짜별로 저장합니다.\r\nspacetrack ID와 Password를 spacetrack_auth에 저장하는 과정이 필요합니다.\r\n\r\n* process1 \r\n입력한 날짜의 TLE를 불러와 고도 2,000km이하일 경우 Epoch기준 subpoint에서의 궤적(총 10초, 1초 간격)을 생성합니다. \r\n기준날짜(입력한 날짜)의 전 날의 TLE도 함께 불러온 후 기준날짜와 동일한 Norad ID의 TLE epoch가 90분 이상의 차이가 날 경우 동일 시간동안 전파합니다. \r\n두 날짜의 TLE에서 생성한 전파 궤적과 궤도요소 정보를 YYYYMMDD_result_raw.csv파일로 중간저장합니다.\r\n\r\n* process2 \r\nYYYYMMDD_result_raw.csv를 불러온 후 기준날짜와 전날짜 기준 Apparent Angular Velocity, Motion Angle을 계산하고 \r\n수직방향 및 수평방향 거리인 D1, D2를 계산하여 최종 결과파일인 YYYYMMDD_result.csv파일을 저장합니다.\r\n\r\n* process3\r\n실행 후 원하는 Norad ID를 input으로 입력하면 YYYYMMDD_result_raw.csv 및 YYYYMMDD_result.csv기반 그래프를 생성합니다.\r\n\r\nmain process1-2과정을 자동으로 진행합니다.\r\n'''\r\n\r\nfrom process1_tracks import main as run_tle\r\nimport subprocess\r\nimport sys\r\nfrom datetime import datetime, timedelta\r\n\r\ntoday = input(\"INPUT YYYYMMDD : \").strip()\r\n\r\ndt = datetime.strptime(today, \"%Y%m%d\")\r\nprev = (dt - timedelta(days=1)).strftime(\"%Y%m%d\")\r\n\r\nif __name__ == \"__main__\":\r\n    # 1) TLE → epoch track CSV\r\n    sys.argv = [\r\n        \"main.py\",\r\n        \"--today\", f\"repository/tle_data/{today}.tle\",\r\n        \"--prev\",  f\"repository/tle_data/{prev}.tle\",\r\n        \"--out\",   f\"{today}_result_raw.csv\",\r\n    ]\r\n    run_tle()\r\n\r\n    # 2) dv/dm/d1/d2 계산\r\n    subprocess.run([\r\n        sys.executable,\r\n        \"process2_calculate.py\",\r\n        f\"{today}_result_raw.csv\",\r\n        f\"{today}_result.csv\",\r\n    ], check=True)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision ffff2866581a3384db8dc4bb5b7932a2ce5c8034)
+++ b/main.py	(date 1769475863518)
@@ -31,7 +31,7 @@
 
 
 * process0 
-spacetrack에서 원하는 기간동안의 decay message와 tip message를 다운받아 날짜별로 저장합니다.
+spacetrack에서 원하는 기간동안의 decay_data message와 tip_data message를 다운받아 날짜별로 저장합니다.
 spacetrack ID와 Password를 spacetrack_auth에 저장하는 과정이 필요합니다.
 
 * process1 
Index: process1_tracks.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># skyfield_tle_epoch_subsat_track_csv.py\r\n# -----------------------------------------------------------------------------\r\n# 목적\r\n# - \"today TLE\" 기준으로: 각 위성(NORAD ID)의 TLE epoch 시각(t0)에서\r\n#   \"epoch 직하점(subsatellite point)의 해발 0m 관측지\"를 가정하고\r\n#   t0 ± 5초 구간을 1초 간격으로 (Topocentric) RA/Dec + Az/El을 계산\r\n# - \"prev-day TLE 목록\"에서 같은 NORAD ID가 있으면:\r\n#   prev TLE epoch와 today TLE epoch 차이가 90분(=5400s) 이상일 때만\r\n#   동일한 시각(t0±5s)에 대해 prev TLE로도 전파하여 비교값 계산\r\n# - CSV 출력:\r\n#   norad_id, object_name, epoch_time_utc,\r\n#   site_lat_deg, site_lon_deg, site_alt_m,\r\n#   t_offset_s,\r\n#   today_ra_deg, today_dec_deg, today_az_deg, today_el_deg,\r\n#   prev_ra_deg,  prev_dec_deg,  prev_az_deg,  prev_el_deg,\r\n#   prev_epoch_time_utc, epoch_diff_sec\r\n#\r\n# 실행 예:\r\n#   python skyfield_tle_epoch_subsat_track_csv.py \\\r\n#       --today today.tle --prev prev_day.tle --out out.csv\r\n# -----------------------------------------------------------------------------\r\n\r\nfrom __future__ import annotations\r\n\r\nimport argparse\r\nimport csv\r\nimport math\r\n\r\nfrom typing import Dict, List, Optional, Tuple\r\nfrom skyfield.api import EarthSatellite, load, wgs84\r\n\r\n\r\n# --------------------------------------------\r\n# Helpers\r\n# --------------------------------------------\r\ndef _safe_float(x: float) -> float:\r\n    try:\r\n        if x is None:\r\n            return float(\"nan\")\r\n        return float(x)\r\n    except Exception:\r\n        return float(\"nan\")\r\n\r\n\r\ndef _time_iso_utc(t) -> str:\r\n    # Skyfield Time -> ISO-like UTC string\r\n    # (utc_iso() produces \"YYYY-MM-DDTHH:MM:SSZ\")\r\n    try:\r\n        return t.utc_iso()\r\n    except Exception:\r\n        # fallback\r\n        y, mo, d, hh, mm, ss = t.utc\r\n        # ss may be float\r\n        return f\"{int(y):04d}-{int(mo):02d}-{int(d):02d}T{int(hh):02d}:{int(mm):02d}:{ss:06.3f}Z\"\r\n\r\n\r\ndef parse_tle_file(path: str, ts) -> Dict[int, Dict]:\r\n    \"\"\"\r\n    return dict keyed by NORAD ID:\r\n      {\r\n        satno: {\r\n          \"name\": str,\r\n          \"l1\": str,\r\n          \"l2\": str,\r\n          \"sat\": EarthSatellite,\r\n          \"epoch\": Time\r\n        },\r\n        ...\r\n      }\r\n    \"\"\"\r\n    out: Dict[int, Dict] = {}\r\n    with open(path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\r\n        lines = [ln.rstrip(\"\\n\") for ln in f if ln.strip()]\r\n\r\n    i = 0\r\n    while i < len(lines):\r\n        line = lines[i].strip()\r\n        if line.startswith(\"1 \") and (i + 1) < len(lines) and lines[i + 1].lstrip().startswith(\"2 \"):\r\n            name = \"\"  # no name line\r\n            l1 = lines[i].strip()\r\n            l2 = lines[i + 1].strip()\r\n            i += 2\r\n        else:\r\n            # name + line1 + line2\r\n            if (i + 2) >= len(lines):\r\n                break\r\n            name = lines[i].strip(\"0 \")\r\n            l1 = lines[i + 1].strip()\r\n            l2 = lines[i + 2].strip()\r\n            i += 3\r\n\r\n        # basic validation\r\n        if not (l1.startswith(\"1 \") and l2.startswith(\"2 \")):\r\n            continue\r\n\r\n        # NORAD ID columns 3-7 in TLE line1 (0-index [2:7])\r\n        try:\r\n            satno = int(l1[2:7])\r\n        except Exception:\r\n            continue\r\n\r\n        try:\r\n            sat = EarthSatellite(l1, l2, name=name, ts=ts)\r\n            epoch = sat.epoch\r\n        except Exception:\r\n            continue\r\n\r\n        out[satno] = {\"name\": name, \"l1\": l1, \"l2\": l2, \"sat\": sat, \"epoch\": epoch}\r\n\r\n    return out\r\n\r\n\r\ndef find_prev_candidate(prev_map: Dict[int, Dict], satno: int) -> Optional[Dict]:\r\n    \"\"\"\r\n    prev TLE 파일에 satno가 있으면 그 항목 반환.\r\n    (여러 개를 지원하려면 이 구조를 리스트로 바꾸면 됨.)\r\n    \"\"\"\r\n    return prev_map.get(satno)\r\n\r\n\r\ndef subsat_site_from_sat_at_epoch(sat: EarthSatellite):\r\n    \"\"\"\r\n    today TLE의 epoch 시각에서 위성 직하점(subpoint) -> 관측지(해발 0m)\r\n    returns: (site, lat_deg, lon_deg)\r\n    \"\"\"\r\n    t0 = sat.epoch\r\n    sp = sat.at(t0).subpoint()\r\n    lat_deg = sp.latitude.degrees\r\n    lon_deg = sp.longitude.degrees  # East-positive, [-180,180] range typically\r\n    # 해발 0m로 고정\r\n    site = wgs84.latlon(latitude_degrees=lat_deg, longitude_degrees=lon_deg, elevation_m=0.0)\r\n    #print(site)\r\n    return site, lat_deg, lon_deg\r\n\r\n\r\ndef topocentric_angles(sat: EarthSatellite, t, site):\r\n    \"\"\"\r\n    returns (ra_deg, dec_deg, az_deg, el_deg)\r\n    - RA/Dec: topocentric apparent RA/Dec\r\n    - Az/El: topocentric azimuth/elevation\r\n    \"\"\"\r\n    top = (sat - site).at(t)\r\n\r\n    # RA/Dec\r\n    ra, dec, _ = top.radec()  # by default apparent\r\n    ra_deg = ra.hours * 15.0\r\n    dec_deg = dec.degrees\r\n\r\n    # Az/El\r\n    az, alt, _ = top.altaz()\r\n    az_deg = az.degrees\r\n    el_deg = alt.degrees\r\n    return ra_deg, dec_deg, az_deg, el_deg\r\n\r\ndef is_leo_by_epoch_altitude(sat: EarthSatellite, max_alt_km=2000.0) -> bool:\r\n    t0 = sat.epoch\r\n    sp = sat.at(t0).subpoint()\r\n    alt_km = sp.elevation.m / 1000.0\r\n    return alt_km <= max_alt_km\r\n\r\n\r\ndef tle_elements_from_sat(sat: EarthSatellite) -> Tuple[float, float, float, float, float, float]:\r\n\r\n    m = sat.model  # sgp4 model object\r\n\r\n    bstar = float(getattr(m, \"bstar\", float(\"nan\")))\r\n\r\n    inc_deg  = float(getattr(m, \"inclo\", float(\"nan\"))) * 180.0 / math.pi\r\n    raan_deg = float(getattr(m, \"nodeo\", float(\"nan\"))) * 180.0 / math.pi\r\n    argp_deg = float(getattr(m, \"argpo\", float(\"nan\"))) * 180.0 / math.pi\r\n    ma_deg   = float(getattr(m, \"mo\",    float(\"nan\"))) * 180.0 / math.pi\r\n\r\n    # mean motion: sgp4는 보통 rad/min 단위(no_kozai)를 가짐\r\n    n_rad_per_min = float(getattr(m, \"no_kozai\", float(\"nan\")))\r\n    mm_rev_per_day = n_rad_per_min * (1440.0 / (2.0 * math.pi))  # rev/day\r\n\r\n    return bstar, inc_deg, raan_deg, argp_deg, ma_deg, mm_rev_per_day\r\n\r\n\r\n\r\n# --------------------------------------------\r\n# Main\r\n# --------------------------------------------\r\ndef main():\r\n    ap = argparse.ArgumentParser()\r\n    ap.add_argument(\"--today\", required=True, help=\"today TLE file path\")\r\n    ap.add_argument(\"--prev\", required=True, help=\"prev-day TLE file path\")\r\n    ap.add_argument(\"--out\", required=True, help=\"output CSV path\")\r\n    ap.add_argument(\"--window_s\", type=int, default=5, help=\"half window seconds (default=5)\")\r\n    ap.add_argument(\"--step_s\", type=int, default=1, help=\"step seconds (default=1)\")\r\n    ap.add_argument(\"--min_epoch_diff_s\", type=int, default=5400, help=\"min epoch diff to compute prev-track (default=5400 = 90min)\")\r\n    args = ap.parse_args()\r\n\r\n    ts = load.timescale()\r\n\r\n    today_map = parse_tle_file(args.today, ts)\r\n    prev_map = parse_tle_file(args.prev, ts)\r\n\r\n    fieldnames = [\r\n        \"norad_id\",\r\n        \"object_name\",\r\n        \"epoch_time_utc\",\r\n        \"site_lat_deg\",\r\n        \"site_lon_deg\",\r\n        \"site_alt_m\",\r\n        \"t_offset_s\",\r\n        \"today_ra_deg\",\r\n        \"today_dec_deg\",\r\n        \"today_az_deg\",\r\n        \"today_el_deg\",\r\n        \"prev_ra_deg\",\r\n        \"prev_dec_deg\",\r\n        \"prev_az_deg\",\r\n        \"prev_el_deg\",\r\n        \"prev_epoch_time_utc\",\r\n        \"epoch_diff_sec\",\r\n        \"Bstar\",\r\n        \"Inc_deg\",\r\n        \"RAAN_deg\",\r\n        \"AP_deg\",\r\n        \"MA_deg\",\r\n        \"MM_rev/day\"\r\n    ]\r\n\r\n    with open(args.out, \"w\", newline=\"\", encoding=\"utf-8-sig\") as f:\r\n        w = csv.DictWriter(f, fieldnames=fieldnames)\r\n        w.writeheader()\r\n\r\n        for satno, item_today in today_map.items():\r\n            sat_today: EarthSatellite = item_today[\"sat\"]\r\n            bstar, inc_deg, raan_deg, ap_deg, ma_deg, mm_rpd = tle_elements_from_sat(sat_today)\r\n\r\n            if not is_leo_by_epoch_altitude(sat_today, max_alt_km=2000.0):\r\n                continue\r\n\r\n            name = item_today[\"name\"] or \"\"\r\n            t0 = sat_today.epoch\r\n\r\n            # 관측지 = today epoch에서의 직하점, 해발 0m\r\n            site, site_lat_deg, site_lon_deg = subsat_site_from_sat_at_epoch(sat_today)\r\n\r\n            # prev 후보\r\n            prev_item = find_prev_candidate(prev_map, satno)\r\n            sat_prev: Optional[EarthSatellite] = None\r\n            prev_epoch_iso = \"\"\r\n            epoch_diff_sec = float(\"nan\")\r\n            use_prev = False\r\n\r\n            if prev_item is not None:\r\n                sat_prev = prev_item[\"sat\"]\r\n                tprev = sat_prev.epoch\r\n                epoch_diff_sec = abs((t0.tt - tprev.tt) * 86400.0)\r\n                prev_epoch_iso = _time_iso_utc(tprev)\r\n                use_prev = (epoch_diff_sec >= args.min_epoch_diff_s)\r\n\r\n            # t0 ± window, step\r\n            for dt in range(-args.window_s, args.window_s + 1, args.step_s):\r\n                t = ts.tt_jd(t0.tt + dt / 86400.0)\r\n\r\n                # today angles\r\n                try:\r\n                    ra_t, dec_t, az_t, el_t = topocentric_angles(sat_today, t, site)\r\n                except Exception:\r\n                    ra_t = dec_t = az_t = el_t = float(\"nan\")\r\n\r\n                # prev angles (only if epoch diff >= threshold and sat exists)\r\n                if use_prev and sat_prev is not None:\r\n                    try:\r\n                        ra_p, dec_p, az_p, el_p = topocentric_angles(sat_prev, t, site)\r\n                    except Exception:\r\n                        ra_p = dec_p = az_p = el_p = float(\"nan\")\r\n                else:\r\n                    ra_p = dec_p = az_p = el_p = float(\"nan\")\r\n\r\n                w.writerow(\r\n                    {\r\n                        \"norad_id\": satno,\r\n                        \"object_name\": name,\r\n                        \"epoch_time_utc\": _time_iso_utc(t0),\r\n                        \"site_lat_deg\": f\"{site_lat_deg:.4f}\",\r\n                        \"site_lon_deg\": f\"{site_lon_deg:.4f}\",\r\n                        \"site_alt_m\": \"0.0\",\r\n                        \"t_offset_s\": dt,\r\n                        \"today_ra_deg\": f\"{_safe_float(ra_t):.4f}\",\r\n                        \"today_dec_deg\": f\"{_safe_float(dec_t):.4f}\",\r\n                        \"today_az_deg\": f\"{_safe_float(az_t):.4f}\",\r\n                        \"today_el_deg\": f\"{_safe_float(el_t):.4f}\",\r\n                        \"prev_ra_deg\": f\"{_safe_float(ra_p):.4f}\",\r\n                        \"prev_dec_deg\": f\"{_safe_float(dec_p):.4f}\",\r\n                        \"prev_az_deg\": f\"{_safe_float(az_p):.4f}\",\r\n                        \"prev_el_deg\": f\"{_safe_float(el_p):.4f}\",\r\n                        \"prev_epoch_time_utc\": prev_epoch_iso,\r\n                        \"epoch_diff_sec\": f\"{_safe_float(epoch_diff_sec):.3f}\",\r\n                        #TLE에서 얻을 수 있는 정보들 추가함!!\r\n                        \"Bstar\": f\"{_safe_float(bstar):.6e}\",\r\n                        \"Inc_deg\": f\"{_safe_float(inc_deg):.4f}\",\r\n                        \"RAAN_deg\": f\"{_safe_float(raan_deg):.4f}\",\r\n                        \"AP_deg\": f\"{_safe_float(ap_deg):.4f}\",\r\n                        \"MA_deg\": f\"{_safe_float(ma_deg):.4f}\",\r\n                        \"MM_rev/day\": f\"{_safe_float(mm_rpd):.8f}\",\r\n                    }\r\n                )\r\n\r\n\r\n'''if __name__ == \"__main__\":\r\n    import sys\r\n    if len(sys.argv) == 1:\r\n        sys.argv += [\r\n            \"--today\", \"repository/tle_data/20250517.tle\",\r\n            \"--prev\",  \"repository/tle_data/20250516.tle\",\r\n            \"--out\",   f\"20250517_result.csv\",\r\n        ]\r\n    main()'''\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/process1_tracks.py b/process1_tracks.py
--- a/process1_tracks.py	(revision ffff2866581a3384db8dc4bb5b7932a2ce5c8034)
+++ b/process1_tracks.py	(date 1769408322921)
@@ -310,5 +310,4 @@
             "--prev",  "repository/tle_data/20250516.tle",
             "--out",   f"20250517_result.csv",
         ]
-    main()'''
-
+    main()'''
\ No newline at end of file
